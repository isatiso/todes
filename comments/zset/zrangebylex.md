> - **Redis官方文档**：https://redis.io/commands/zrangebylex
> - **起始版本**：2.8.9
> - **时间复杂度**：O(log(N)+M) N 是排序集中的成员数量，M 是需要返回的成员数量。
    > 如果 M 始终是个常量（比如使用 limit 限制始终返回前 10 个元素），此时可以认为复杂度为 O(log(N))。

当排序集中的全部成员含有相同的 score 时，成员按照字典序排列，ZRANGEBYLEX 可以在这种情况下返回字典序介于 min 和 max 之间的所有成员。

成员按照从低到高的顺序排列，比较方式是 c 函数 memcmp()，也就是逐个字节比较字符串。如果公共部分相同，更长的字符串更大。

在 Redis 6.2.0 版本，这个命令可能被废弃。请在新代码中使用带 BYLEX 参数的 [[RedisSortedSetClient.zrange | ZRANGE]] 命令。

可选参数 limit 可以用来限制返回成员数量（类似 SQL 中的 SELECT LIMIT offset, count）。负数的 count 表示返回 offset 后的全部元素。
需要注意的是，如果 offset 很大，排序集在找到需要返回的元素前要先遍历 offset 个元素。这可能会增加 O(N) 的复杂度。

### 如何指定区间

合法的 min 和 max 值需要以 `[` 或者 `(` 开头，分别表示端值被包含和不被包含。特殊值 `+` 和 `-` 分表表示无穷大和无穷小的字符串。
所以当全部成员有相同的分数时 `await client.zrangebylex('zset', '-', '+')` 表示选择全部成员。

### 字符串比较细节

字符串作为字节数组进行比较，这在使用纯 ASCII 编码时没有问题，因为 ASCII 编码的字节顺序就是按照字典顺序来的。但是在使用其他字符编码是情况则不一定如此，比如 UTF-8 编码。

另外，用户可以自己做一个转码，保证最前面部分的字符串编码是按照期望进行排列的。

比如，你希望进行一个大小写不敏感的字符串排序，但是又希望保留原始字符串，那你可以如下设置一个排序集：

zset `{ 'foo:Foo': 0, 'bar:BAR': 0, 'zap:zap': 0 }`

将全部字符转为小写，并通过分号和原字符串拼接起来。由于分号的字节比所有字母都要大，所以可以通过这种方式强制按照分号前的部分进行排序。而应用可以根据查询结果进行分割限制后面一部分的实际内容。

利用二进制进行比较的特性，可以让排序集成为通用索引。
例如，元素的第一部分可以是 64 位大端数字：由于大端数字在初始位置具有最高有效字节，因此二进制比较的结果和直接比较数字是一致的。
可以使用它来对 64 位值执行范围查询。

例子：

```typescript
await client.zadd('zset', { a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0 })
// 7
await client.zrangebylex('zset', '-', '[c')
// ["a", "b", "c"]
await client.zrangebylex('zset', '-', '(c')
// ["a", "b"]
await client.zrangebylex('zset', '[aaa', '(g')
// ["b", "c", "d", "e", "f"]
```
